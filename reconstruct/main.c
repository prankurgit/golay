unsigned char ts2[128] = {0x4d, 0x46, 0x77, 0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0x68, 
													0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x53, 0x77, 
													0x41, 0x77, 0x53, 0x41, 0x4a, 0x42, 0x41, 0x4b, 0x44, 0x78, 0x64, 0x74, 0x6d, 
													0x6f, 0x73, 0x72, 0x4e, 0x63, 0x6c, 0x4c, 0x4f, 0x6b, 0x57, 0x72, 0x36, 0x74,
													0x4b, 0x57, 0x56, 0x48, 0x67, 0x48, 0x69, 0x4e, 0x73, 0x48, 0x72, 0x2f, 0x49, 
													0x47, 0x54, 0x68, 0x77, 0x4e, 0x4b, 0x79, 0x42, 0x43, 0x78, 0x33, 0x72, 0x67, 
													0x32, 0x61, 0x39, 0x73, 0x36, 0x46, 0x64, 0x38, 0x74, 0x61, 0x4a, 0x2b, 0x58, 
													0x52, 0x42, 0x68, 0x63, 0x4e, 0x6f, 0x49, 0x42, 0x38, 0x43, 0x52, 0x67, 0x66, 
													0x2f, 0x62, 0x72, 0x44, 0x6b, 0x44, 0x65, 0x76, 0x4d, 0x53, 0x5a, 0x39, 0x79, 
													0x72, 0x73, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x51, 0x3d, 0x3d};
													
// RSA private Key (valid)													
unsigned char ts[428] = { 0x4d, 0x49, 0x49, 0x42, 0x4f, 0x77, 0x49, 0x42, 0x41, 0x41, 0x4a, 0x42, 0x41, 0x4b, 0x44, 
													0x78, 0x64, 0x74, 0x6d, 0x6f, 0x73, 0x72, 0x4e, 0x63, 0x6c, 0x4c, 0x4f, 0x6b, 0x57, 0x72, 
													0x36, 0x74, 0x4b, 0x57, 0x56, 0x48, 0x67, 0x48, 0x69, 0x4e, 0x73, 0x48, 0x72, 0x2f, 0x49, 
													0x47, 0x54, 0x68, 0x77, 0x4e, 0x4b, 0x79, 0x42, 0x43, 0x78, 0x33, 0x72, 0x67, 0x32, 0x61, 
													0x39, 0x73, 0x36, 0x46, 0x64, 0x38, 0x74, 0x61, 0x4a, 0x2b, 0x58, 0x52, 0x42, 0x68, 0x63, 
													0x4e, 0x6f, 0x49, 0x42, 0x38, 0x43, 0x52, 0x67, 0x66, 0x2f, 0x62, 0x72, 0x44, 0x6b, 0x44, 
													0x65, 0x76, 0x4d, 0x53, 0x5a, 0x39, 0x79, 0x72, 0x73, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 
													0x51, 0x4a, 0x41, 0x61, 0x50, 0x4d, 0x4d, 0x66, 0x59, 0x4c, 0x30, 0x68, 0x4f, 0x47, 0x71,
													0x56, 0x6a, 0x71, 0x6d, 0x73, 0x68, 0x42, 0x5a, 0x48, 0x69, 0x49, 0x79, 0x4e, 0x47, 0x71, 
													0x77, 0x32, 0x6f, 0x50, 0x6a, 0x71, 0x2b, 0x56, 0x4b, 0x79, 0x42, 0x6f, 0x74, 0x66, 0x70, 
													0x44, 0x43, 0x52, 0x79, 0x42, 0x47, 0x79, 0x67, 0x42, 0x36, 0x33, 0x6b, 0x52, 0x34, 0x75, 
													0x43, 0x5a, 0x6b, 0x70, 0x50, 0x6c, 0x77, 0x44, 0x70, 0x34, 0x45, 0x2f, 0x50, 0x54, 0x71, 
													0x62, 0x4f, 0x50, 0x6a, 0x70, 0x53, 0x57, 0x49, 0x30, 0x76, 0x6d, 0x78, 0x41, 0x51, 0x49, 
													0x68, 0x41, 0x4f, 0x47, 0x79, 0x6f, 0x33, 0x53, 0x66, 0x4a, 0x4e, 0x55, 0x4c, 0x63, 0x44, 
													0x4b, 0x62, 0x48, 0x6d, 0x45, 0x4c, 0x44, 0x46, 0x4e, 0x57, 0x44, 0x68, 0x64, 0x67, 0x32, 
													0x39, 0x74, 0x6a, 0x51, 0x67, 0x32, 0x56, 0x35, 0x75, 0x46, 0x32, 0x4e, 0x62, 0x6d, 0x54, 
													0x41, 0x69, 0x45, 0x41, 0x74, 0x6f, 0x30, 0x73, 0x68, 0x64, 0x79, 0x47, 0x52, 0x66, 0x72, 
													0x63, 0x73, 0x4a, 0x64, 0x35, 0x63, 0x65, 0x54, 0x51, 0x39, 0x7a, 0x32, 0x30, 0x70, 0x39, 
													0x6d, 0x64, 0x61, 0x72, 0x47, 0x44, 0x68, 0x52, 0x48, 0x64, 0x67, 0x55, 0x6a, 0x79, 0x51, 
													0x7a, 0x6b, 0x43, 0x49, 0x51, 0x43, 0x50, 0x2b, 0x72, 0x58, 0x72, 0x6e, 0x39, 0x71, 0x50, 
													0x54, 0x6b, 0x79, 0x30, 0x2b, 0x39, 0x2f, 0x56, 0x61, 0x49, 0x62, 0x6b, 0x59, 0x76, 0x46, 
													0x36, 0x57, 0x48, 0x2f, 0x6f, 0x35, 0x4e, 0x6b, 0x75, 0x63, 0x59, 0x4a, 0x6f, 0x4d, 0x6c, 
													0x44, 0x7a, 0x6f, 0x51, 0x49, 0x68, 0x41, 0x49, 0x75, 0x44, 0x58, 0x50, 0x46, 0x34, 0x31, 
													0x63, 0x32, 0x4a, 0x71, 0x54, 0x76, 0x30, 0x70, 0x38, 0x58, 0x5a, 0x58, 0x37, 0x4a, 0x30, 
													0x6f, 0x43, 0x70, 0x66, 0x62, 0x36, 0x54, 0x6f, 0x77, 0x57, 0x44, 0x6a, 0x68, 0x47, 0x75, 
													0x58, 0x2b, 0x6a, 0x35, 0x52, 0x41, 0x69, 0x42, 0x4d, 0x36, 0x44, 0x76, 0x34, 0x63, 0x6b, 
													0x65, 0x44, 0x54, 0x2f, 0x54, 0x7a, 0x59, 0x2b, 0x44, 0x48, 0x5a, 0x42, 0x76, 0x68, 0x63, 
													0x66, 0x38, 0x46, 0x74, 0x70, 0x46, 0x34, 0x41, 0x35, 0x5a, 0x2f, 0x44, 0x42, 0x45, 0x39, 
													0x67, 0x74, 0x62, 0x6d, 0x75, 0x41, 0x3d, 0x3d};



//*****************************************************************************
//
//*****************************************************************************
//
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
#include "inttypes.h"

//
//*****************************************************************************
// Define GOLAY DATA
#define X22             0x00400000   /* vector representation of X^{22} */
#define X11             0x00000800   /* vector representation of X^{11} */
#define MASK12          0xfffff800   /* auxiliary vector for testing */
#define GENPOL          0x00000c75   /* generator polinomial, g(x) */

//
//*****************************************************************************
//
#ifdef DEBUG
//
//*****************************************************************************
//
void
__error__(char *pcFilename, unsigned long ulLine)
{
}
#endif
//
//*****************************************************************************
//
// GOLAY Code: funktions and declarations
long pattern;
long decoding_table[2048];
long position[23] = { 0x00000001, 0x00000002, 0x00000004, 0x00000008,
                      0x00000010, 0x00000020, 0x00000040, 0x00000080,
                      0x00000100, 0x00000200, 0x00000400, 0x00000800,
                      0x00001000, 0x00002000, 0x00004000, 0x00008000,
                      0x00010000, 0x00020000, 0x00040000, 0x00080000,
                      0x00100000, 0x00200000, 0x00400000 };
int a[4];										
//
//*****************************************************************************
//
long arr2int(a,r)
/*
 * Convert a binary vector of Hamming weight r, and nonzero positions in
 * array a[1]...a[r], to a long integer \sum_{i=1}^r 2^{a[i]-1}.
 */
int r;
int *a;
{
   int i;
   long mul, result = 0, temp;

   for (i=1; i<=r; i++) {
      mul = 1;
      temp = a[i]-1;
      while (temp--)
         mul = mul << 1;
      result += mul;
      }
   return(result);
}
//
//*****************************************************************************
//
void nextcomb(n, r, a)
/*
 * Calculate next r-combination of an n-set.
 */
int  n, r;
int  *a;
{
  int  i, j;

  a[r]++;
  if (a[r] <= n)
      return;
  j = r - 1;
  while (a[j] == n - r + j)
     j--;
  for (i = r; i >= j; i--)
      a[i] = a[j] + i - j + 1;
  return;
}
//
//*****************************************************************************
//
long get_syndrome(pattern)
/*
 * Compute the syndrome corresponding to the given pattern, i.e., the
 * remainder after dividing the pattern (when considering it as the vector
 * representation of a polynomial) by the generator polynomial, GENPOL.
 * In the program this pattern has several meanings: (1) pattern = infomation
 * bits, when constructing the encoding table; (2) pattern = error pattern,
 * when constructing the decoding table; and (3) pattern = received vector, to
 * obtain its syndrome in decoding.
 */
long pattern;
{
    long aux = X22;

    if (pattern >= X11)
       while (pattern & MASK12) {
           while (!(aux & pattern))
              aux = aux >> 1;
           pattern ^= (aux/X11) * GENPOL;
           }
    return(pattern);
}
//****************************** END GOLAY Functions ***********************************************
//
// ########################## START MAJORITYVOTE ##############################
// binary bitwise MajorityVoting
int majorityVoting(unsigned long pos, int fact){
	int c = 0;
	int zero = 0;
	int one = 0;
	unsigned long posi = pos;
    while(c < fact){
       if( ((posi >> ((fact-1)-c)) & 0x00000001) == 1){
           one++;
           }
        else{
            zero++;
        }
        c++;
    }
    if(zero > one) {			
			return 0;}
    else {
			return 1;}
}
// ########################## END MAJORITYVOTE ##############################
//
//############################## START DECODING ##########################
int recoverOriginalData(volatile unsigned char *sramData, int LRfactor, int originalSecretSize, int len, char *typ){
// Variables of this function
int i = 0;
int j = 0;
int k = 0;
long recd, recd2, temp;
unsigned long pos8 = 0, pos7 = 0 ,pos6 = 0 , pos5 = 0, pos4 = 0, pos3 = 0, pos2 = 0, pos1 = 0;
unsigned char recLR = 0x00;
unsigned char *recoverdFromLR = malloc(sizeof(unsigned char) * len);
unsigned char *recoverdSecret = malloc(sizeof(unsigned char) * originalSecretSize);
unsigned char *helperData = malloc(sizeof(unsigned char) * (len*LRfactor));


//get helper data from file
char strin[100];

FILE *ptr2;
if (LRfactor == 7){
    if (typ == "pu"){
        printf("Give the file path to file \"helperdata7pu\": ");
        scanf("%s", strin);
        if (strin[0] == 'C')
            strcat(strin,":\\Users\\Nikolas\\Desktop\\NetBeansProjects\\generate\\helperdata7pu.bin");
        else strcat(strin,"\\helperdata7pu.bin");
        ptr2 = fopen( strin, "rb" );
    }
    else {
        printf("Give the file path to file \"helperdata7pr\": ");
        scanf("%s", strin);
        if (strin[0] == 'C')
            strcat(strin,":\\Users\\Nikolas\\Desktop\\NetBeansProjects\\generate\\helperdata7pr.bin");
        else strcat(strin,"\\helperdata7pr.bin");
        ptr2 = fopen( strin, "rb" );
    }
}
if (LRfactor == 15){
    if (typ == "pu"){
        printf("Give the file path to file \"helperdata15pu\": ");
        scanf("%s", strin);
        if (strin[0] == 'C')
            strcat(strin,":\\Users\\Nikolas\\Desktop\\NetBeansProjects\\generate\\helperdata15pu.bin");
        else strcat(strin,"\\helperdata15pu.bin");
        ptr2 = fopen( strin, "rb" );
    }
    else {
        printf("Give the file path to file \"helperdata15pr\": ");
        scanf("%s", strin);
        if (strin[0] == 'C')
            strcat(strin,":\\Users\\Nikolas\\Desktop\\NetBeansProjects\\generate\\helperdata15pr.bin");
        else strcat(strin,"\\helperdata15pr.bin");
        ptr2 = fopen( strin, "rb" );
    }
}
if (!ptr2)
{
printf("Unable to open file 2!");
return 1;
}
fread(helperData,sizeof(unsigned char),(len*LRfactor),ptr2);


fclose(ptr2);

	
	/*
    * ---------------------------------------------------------------------
    *                  Generate GOLAY DECODING TABLE
    *
    * An entry to the decoding table is a syndrome and the resulting value
    * is the most likely error pattern. First an error pattern is generated.
    * Then its syndrome is calculated and used as a pointer to the table
    * where the error pattern value is stored.
    * ---------------------------------------------------------------------
    *
    * (1) Error patterns of WEIGHT 1 (SINGLE ERRORS)
    */
    decoding_table[0] = 0;
    decoding_table[1] = 1;
    temp = 1;
    for (i=2; i<= 23; i++) {
        temp *= 2;
        decoding_table[get_syndrome(temp)] = temp;
        }
   /*
    * (2) Error patterns of WEIGHT 2 (DOUBLE ERRORS)
    */
    a[1] = 1; a[2] = 2;
    temp = arr2int(a,2);
    decoding_table[get_syndrome(temp)] = temp;
    for (i=1; i<253; i++) {
        nextcomb(23,2,a);
        temp = arr2int(a,2);
        decoding_table[get_syndrome(temp)] = temp;
        }
   /*
    * (3) Error patterns of WEIGHT 3 (TRIPLE ERRORS)
    */
    a[1] = 1; a[2] = 2; a[3] = 3;
    temp = arr2int(a,3);
    decoding_table[get_syndrome(temp)] = temp;
    for (i=1; i<1771; i++) {
        nextcomb(23,3,a);
        temp = arr2int(a,3);
        decoding_table[get_syndrome(temp)] = temp;
        }
//****************************** END GOLAY Functions ***********************************************
		/* ---------------------------------------------------------------------
    *                        decode Codeword DATA
    * ---------------------------------------------------------------------
    */
j = 0;
if(LRfactor == 7){
	while (j < len){
				recLR = 0x00;
				pos8 = (helperData[(j*LRfactor)] ^ sramData[(j*LRfactor)]) >> 1;
					 if(majorityVoting(pos8, LRfactor)) {
								recLR = 0x80;
					 }
				pos7 = ((helperData[((j*LRfactor)+1)] ^ sramData[(j*LRfactor)+1]) >> 2) ^ (((helperData[(j*LRfactor)] ^ sramData[(j*LRfactor)]) & 0x01) << 6);
						if(majorityVoting(pos7, LRfactor)){
									 recLR = (recLR ^ 0x40);
						}
				pos6 = ((helperData[((j*LRfactor)+2)] ^ sramData[(j*LRfactor)+2]) >> 3) ^ (((helperData[((j*LRfactor)+1)] ^ sramData[(j*LRfactor)+1]) & 0x03) << 5);
						if(majorityVoting(pos6, LRfactor)){
										recLR = (recLR ^ 0x20);
						}
				pos5 = ((helperData[((j*LRfactor)+3)] ^ sramData[(j*LRfactor)+3]) >> 4) ^ (((helperData[((j*LRfactor)+2)] ^ sramData[(j*LRfactor)+2]) & 0x07) << 4);
						if(majorityVoting(pos5, LRfactor)){
									 recLR = (recLR ^ 0x10);
						}
				pos4 = ((helperData[((j*LRfactor)+4)] ^ sramData[(j*LRfactor)+4]) >> 5) ^ (((helperData[((j*LRfactor)+3)] ^ sramData[(j*LRfactor)+3]) & 0x0F) << 3);
						if(majorityVoting(pos4, LRfactor)){
										recLR = (recLR ^ 0x08);
						}
				pos3 = ((helperData[((j*LRfactor)+5)] ^ sramData[(j*LRfactor)+5]) >> 6) ^ (((helperData[((j*LRfactor)+4)] ^ sramData[(j*LRfactor)+4]) & 0x1F) << 2);
						if(majorityVoting(pos3, LRfactor)){
										recLR = (recLR ^ 0x04);
						}
				pos2 = ((helperData[((j*LRfactor)+6)] ^ sramData[(j*LRfactor)+6]) >> 7) ^ (((helperData[((j*LRfactor)+5)] ^ sramData[(j*LRfactor)+5]) & 0x3F) << 1);
						if(majorityVoting(pos2, LRfactor)){
										recLR = (recLR ^ 0x02);
						}
				pos1 = ((helperData[((j*LRfactor)+6)] ^ sramData[(j*LRfactor)+6]) & 0x7F);
						if(majorityVoting(pos1, LRfactor)) {
										recLR = (recLR ^ 0x01);
						}
		// set correct recoverd bits
		recoverdFromLR[j] = recLR;
		j++;
	}
}
if(LRfactor == 15){
	while (j < len){
				recLR = 0x00;
				pos8 = ((helperData[(j*LRfactor)] ^ sramData[(j*LRfactor)]) << 7) ^ ((helperData[(j*LRfactor)+1] ^ sramData[(j*LRfactor)+1]) >> 1);
					 if(majorityVoting(pos8, LRfactor)) {
								recLR = 0x80;
					 }
				pos7 = ((((helperData[(j*LRfactor)+1] ^ sramData[(j*LRfactor)+1]) & 0x01) << 14) ^ ((helperData[((j*LRfactor)+2)] ^ sramData[(j*LRfactor)+2]) << 6) ^ ((helperData[(j*LRfactor)+3] ^ sramData[(j*LRfactor)+3]) >> 2));
						if(majorityVoting(pos7, LRfactor)){
									 recLR = (recLR ^ 0x40);
						}
				pos6 = ((((helperData[(j*LRfactor)+3] ^ sramData[(j*LRfactor)+3]) & 0x03) << 13) ^ ((helperData[((j*LRfactor)+4)] ^ sramData[(j*LRfactor)+4]) << 5) ^ ((helperData[(j*LRfactor)+5] ^ sramData[(j*LRfactor)+5]) >> 3));
						if(majorityVoting(pos6, LRfactor)){
										recLR = (recLR ^ 0x20);
						}
				pos5 = ((((helperData[(j*LRfactor)+5] ^ sramData[(j*LRfactor)+5]) & 0x07) << 12) ^ ((helperData[((j*LRfactor)+6)] ^ sramData[(j*LRfactor)+6]) << 4) ^ ((helperData[(j*LRfactor)+7] ^ sramData[(j*LRfactor)+7]) >> 4));
						if(majorityVoting(pos5, LRfactor)){
									 recLR = (recLR ^ 0x10);
						}
				pos4 = ((((helperData[(j*LRfactor)+7] ^ sramData[(j*LRfactor)+7]) & 0x0F) << 11) ^ ((helperData[((j*LRfactor)+8)] ^ sramData[(j*LRfactor)+8]) << 3) ^ ((helperData[(j*LRfactor)+9] ^ sramData[(j*LRfactor)+9]) >> 5));
						if(majorityVoting(pos4, LRfactor)){
										recLR = (recLR ^ 0x08);
						}
				pos3 = ((((helperData[(j*LRfactor)+9] ^ sramData[(j*LRfactor)+9]) & 0x1F) << 10) ^ ((helperData[((j*LRfactor)+10)] ^ sramData[(j*LRfactor)+10]) << 2) ^ ((helperData[(j*LRfactor)+11] ^ sramData[(j*LRfactor)+11]) >> 6));
						if(majorityVoting(pos3, LRfactor)){
										recLR = (recLR ^ 0x04);
						}
				pos2 = ((((helperData[(j*LRfactor)+11] ^ sramData[(j*LRfactor)+11]) & 0x3F) << 9) ^ ((helperData[((j*LRfactor)+12)] ^ sramData[(j*LRfactor)+12]) << 1) ^ ((helperData[(j*LRfactor)+13] ^ sramData[(j*LRfactor)+13]) >> 7));
						if(majorityVoting(pos2, LRfactor)){
										recLR = (recLR ^ 0x02);
						}
				pos1 = ((((helperData[(j*LRfactor)+13] ^ sramData[(j*LRfactor)+13]) & 0x7F) << 8) ^ (helperData[(j*LRfactor)+14] ^ sramData[(j*LRfactor)+14])) ;
						if(majorityVoting(pos1, LRfactor)) {
										recLR = (recLR ^ 0x01);
						}
		// set correct recoverd bits
		recoverdFromLR[j] = recLR;
		j++;
	}
}	
		/* ---------------------------------------------------------------------
    *                        decode original DATA
    * ---------------------------------------------------------------------
    */
k = 0;
while(k < len){
    recd = 0;
    recd2 = 0;
	  recd |= recoverdFromLR[k] << 16;
    recd |= (recoverdFromLR[k+1] << 8);
		recd |= (recoverdFromLR[k+2]);
		recd ^= decoding_table[get_syndrome(recd)];
    recd2 |= recoverdFromLR[k+3] << 16;
    recd2 |= (recoverdFromLR[k+4] << 8);
    recd2 |= (recoverdFromLR[k+5]);
    recd2 ^= decoding_table[get_syndrome(recd2)];
    // Save reconstructed secret 
		recoverdSecret[(k/2)] = (recd >> 15);
		if(((int)((((float)originalSecretSize/3.0f) - (float)((int)originalSecretSize/3))*10) == 3) && ((k+6) > (originalSecretSize*2))){break;}
		recoverdSecret[(k/2)+1] = ((((recd >> 11) & 0x000F) << 4) ^ ((recd2 >> 19) & 0x000F));
		if(((int)((((float)originalSecretSize/3.0f) - (float)((int)originalSecretSize/3))*10) == 6) && ((k+6) > (originalSecretSize*2))){break;}
    recoverdSecret[(k/2)+2] = ((recd2 >> 11) & 0x00FF);
    k = k + 6;
}

free(helperData);
//check if secrets match
int count = 0;
if (typ == "pu"){
    for (i=0; i<sizeof(ts2);i++){
        if (*(recoverdSecret+i) == (ts2[i])){
            count = count + 1;
        }
    }
    if (count == sizeof(ts2)){
        printf("\nYes, they match.\n\n");
    }
    else{
        printf("\nNo, they don't match!!!!\n\n");
    }
}
if (typ == "pr"){
    for (i=0; i<sizeof(ts);i++){
        if (*(recoverdSecret+i) == (ts[i])){
            count = count + 1;
        }
    }
    if (count == sizeof(ts)){
        printf("\nYes, they match.\n\n");
        
    }
    else{
        printf("\nNo, they don't match!!!!\n\n");
        
    }    
}


free(recoverdSecret);
free(recoverdFromLR);
                   
return 0;
}
//###############################################################
// Array and Start Pointer for the saved SRAM DATA and HelperData
unsigned char sram[31744]; //32720		
//
//*****************************************************************************
// Length of the Secret (public- / private- Input) Key 
//
int len;
int originalSize;		
//
//*****************************************************************************
//	Set CPU clock for sync FLASH operations
//													
unsigned long ulOperatingFrequency = 20;// in MHz
//
//*****************************************************************************
int
main(void)
{
    // Copy SRAM DATA from file to memory
FILE *ptr;

char stri[100];
char al[100];

printf("Give the filename: ");
scanf("%s", stri);

if (stri[0] == 'S'){
    al[0]='C';
    strcat(al,":\\Users\\Nikolas\\Dropbox\\Stellaris16\\");
    strcat(al,stri);}

if (al[0] == 'C')
ptr = fopen(al,"rb");
else ptr = fopen(stri,"rb");

if (!ptr)
{
printf("Unable to open file!");
return 1;
}

fseek(ptr, 1024 , SEEK_SET ); //48

fread(sram,1,31744,ptr); //32720

fclose(ptr);

//*****************************************************************************

	// Reconstruct privateKey (length 428 byte)
		// set Input Size and calculate golay length
		originalSize = 428;
		len = ((int)(((float)(originalSize*2)/3.0f)+0.999f)*3);
		recoverOriginalData(sram, 7, originalSize, len,"pr");
                recoverOriginalData(sram, 15, originalSize, len,"pr");

	// Reconstruct publicKey (length 128 byte)
		// set Input Size and calculate golay length
		originalSize = 128;
		len = ((int)(((float)(originalSize*2)/3.0f)+0.999f)*3);
		recoverOriginalData(sram, 7, originalSize, len,"pu");
                recoverOriginalData(sram, 15, originalSize, len,"pu");
		
                return 0;
    //
    // We are finishdested.  Hang around doing nothing.
    //
}
